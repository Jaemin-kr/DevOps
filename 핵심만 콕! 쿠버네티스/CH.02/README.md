# Ch02. 쿠버네티스 소개

## 2.1 쿠버네티스란?

쿠버네티스란 도커를 통해 생성한 컨테이너를 관리하는 시스템이다.

사용자가 여러 장치들로 구성되어 있는 컴퓨터(CPU, MEM, I/O)를 물리적으로 제어하지 않고 윈도우나 리눅스를 통해 컴퓨터를 제어하는 것처럼 쿠버네티스는 다수의 컨테이너를 사용자가 쉽게 조작할 수 있게 돕는다.

쿠버네티스는 구글에서 만들어져 CNCF(Cloud Native Computing Foundation)에 기증하여 오픈소스로 관리되고 있다.

### 2.1.1 컨테이너 오케스트레이션?

<aside>
💡 orchestration(오케스트레이션)
- 오케스트레이션이란 컴퓨터 시스템과 소프트웨어(어플리케이션, 서비스)의 자동화된 구성, 관리, 조정을 의미한다. 관련도구에는 Ansible, Puppet, 테라폼, AWS CloudFormation이 있다.

</aside>

쿠버네티스가 컨테이너의 어떤 부분을 담당하는가?

- 실행 및 배포
- 이중화와 가용성 보장
- 수평확장 및 축소관리
- 스케줄링 담당
- 네트워크 설정 관리
- health 상태 모니터링
- 설정값 관리

### 2.1.2 데이터 센터의 운영체제 → 쿠버네티스

<aside>
💡 운영체제란 컴퓨터의 CPU, 메모리, 디스크, 네트워크 카드 등의 부품으로 이루어진 컴퓨터를 직접적인 물리제어 없이 사용자가 컴퓨터를 사용할 수 있게 해준다.
이처럼  쿠버네티스는 여러대의 서버를 연결하여 하나의 시스템처럼 동작하는 환경을 제공한다.

</aside>

데이터 센터(클러스터)

- 여러 컴퓨터의 집합
- 리소스컴퓨팅 자원의 군집

운영체제

- 하드웨어 추상화
- 프로세스 스케줄링
- 컴퓨팅 자원관리
- 사용자 인터페이스(UI)

## 2.2 쿠버네티스 기본 개념

쿠버네티스는 사용자가 개별노드에 직접 접속하지 않고 쿠버네티스라는 추상화된 계층을 통해 클러스터를 제어할 수 있는 하드웨어 추상화, 컨테이너 스케줄링, 자원할당과 같은 기능을 제공한다. 또한, 운영체제는 GUI를 통해 사용자가 손쉽게 컴퓨터를 제어하지만 쿠버네티스는 kubectl이라는 UI를 이용하여 쿠버네티스를 제어한다

### 2.2.1 애완동물 vs 가축

pet은 cattle과 달리 세심한 관리가 필요하다. 가축은 다수의 개체들을 한번에 이동시키거나 관리를 하지만 애완동물의 경우에는 하나하나 따로 관리가 필요하며 하나의 개체에 대해 신경을 더 많이 쓴다.

쿠버네티스가 서버를 바라보는 관점도 이와 같다. 쿠버네티스는 서버를 하나하나 따로 관리하는 것이 아닌 전체적인 시스템 측면에서 서버를 바라본다. 그렇기 때문에 기존의 웹서버, 메일서버, 모니터링 서버 등과 같이 서버의 이름을 구분하는 것이 아닌 Master와 Worker node로 서버를 구분할 뿐이다.

쿠버네티스는 서버가 죽는데 개의치 않는다. 컨테이너의 장점인 고립성으로 빠른시간내에 같은 역할을 부여한 컨테이너를 생성할 수 있기 때문이다. 쿠버네티스에서 마스터는 쿠버네티스 운용을 위한 필수적인 핵심 컴포넌트가 존재하고 나머지 워커 노드들은 단순히 컨테이너를 실행하는 환경으로만 사용한다.

→ 고립화와 이식성(워커노드를 각각 고립된 환경에서 동작하며 다른 워커노드가 한 일을 기존의 워크노드로도 실행이 가능하다.)

### 2.2.2 바라는 상태(Desired State)

에어컨 현재온도 → 희망온도

바라는 상태를 알고 있기 때문에 시스템에 장애가 발생하더라도 자가치유가 가능하다

### 2.2.3 컨트롤러

사용자가 바라는 상태를 선언하면 쿠버네티스는 바라는 상태를 유지하기 위해 동작하는데 이때 동작을 하는 주체가 컨트롤러이다. 컨트롤러는 control-loop라는 루프를돌며 특정 리소스를 지속적으로 모니터링 하다가 이벤트가 발생하면 이에 따라 특정 작업을 수행한다.

### 2.2.4 쿠버네티스 리소스

쿠버네티스는 모든 것이 리소스로 표현된다. Pod, ReplicaSet, Deployment 등의 다양한 리소스가 존재하고 역할이 있다. 가장 기본적인 리소스는 파드(Pod)로 하나 이상의 컨테이너를 가지는 쿠버네티스의 최소 실행 단위이다.

### 2.2.5 선언형 커맨드(Declarative Command)

<aside>
💡 선언형 커맨드
사용자가 직접 시스템의 상태를 바꾸지 않고 사용자가 바라는 상태를 기술하여 명령을 내리는 방법을 말함. HTML: What(무엇)을 해라

명령형(Imperative) 커맨드
ex) SQL 쿼리 - 특정 데이터에 대해 명령문 작성, HOW(~하게)해라(테이블을 어떻게 해라)

</aside>

HTML <a href> element(명령 선언) → Web → 하이퍼링크 연결

k8s YAML pod선언 명령(YAML 정의서)

### 2.2.6 namespace

k8s는 클러스터레벨 리소스와 네임스페이스레벨 리소스로 구분한다.

쿠버네티스 클러스터 내에서 논리적으로 구분된 구조를 만들어준다.(Like linux process group)

각각의 namespace는 서로다른 권한과 네트워크 정책을 설정할 수 있다.

### 2.2.7 Label & Selector

각 리소스에 라벨을 붙여 selector가 원하는 label을 찾아 리소스간의 연결관계를 표현한다(key-value 형식)

### 2.2.8 서비스 탐색

쿠버네티스 클러스터 내에서 pod사이의 통신을 위한 service endpoint를 찾는과정. k8s는 DNS기반의 서비스 탐색을 지원하므로 도메인 주소를 기반으로 서비스에 접근한다.

### 2.2.9 설정관리

컨테이너 설정에 필요한 설정값 및 민감정보(credentials)를 플랫폼 레벨에서 관리할 수 있는 방법을 제공한다.

ConfigMap, Secret리소스를 이용해 컨테이너 설정을 관리한다.

## 2.4 아키텍처

### 마스터

- API
- etcd(DB)
- kube schedualer
- kube-controller
- cloud-controller manager

### 노드(Worker)

- kubelet: 컨테이너 모니터링 및 api에게 리소스 상태 및 node 정보공유
- kube-proxy: 네트워킹 및 서비스별 IP할당, 클러스터 내/외부의 트래픽을 Pod로 전달할 수 있도록 패킷라우딩
- container runtime: 실제 컨테이너를 실행하는 컨테이너 환경(Docker), Container Runtime Interface 규약만 따른다면 다른 program을 사용해도 무방하다.

### 2.4.0 컨트롤 플레인과 데이터 플레인

쿠버네티스는 컨트롤 플레인과 데이터 플레인으로 구성된다. 컨트롤 플레인은 쿠버네티스 클러스터를 관리하는 API 서버, etcd, 컨트롤러 매니저, 스케줄러 등의 요소로 구성되어 있다. 데이터 플레인은 실제로 컨테이너가 동작하는 노드들로 구성된다.

### 2.4.1 etcd

etcd는 쿠버네티스의 모든 정보를 담고 있는 분산 저장소이다. API 서버, 컨트롤러 매니저, 스케줄러 등의 요소는 모두 etcd에 저장된 정보를 참조하여 클러스터를 관리한다. etcd는 Raft 알고리즘을 사용하여 분산 저장소를 구현하고 있으며, 안정적인 분산 저장소를 제공한다.

### 2.4.2 kubelet

kubelet은 각 노드에서 컨테이너의 상태를 모니터링하고 컨테이너가 올바르게 동작하도록 유지하는 요소이다. kubelet은 API 서버와 통신하여 할당받은 Pod를 실행하고, 컨테이너의 상태를 주기적으로 체크하여 문제가 발생하면 자동으로 복구한다.

### 2.4.3 kubectl

kubectl은 쿠버네티스 클러스터를 제어하기 위한 CLI(Command Line Interface) 도구이다. kubectl을 사용하면 컨테이너를 실행하는 Pod, ReplicaSet, Deployment 등의 리소스를 생성, 수정, 삭제할 수 있다.

### 2.4.4 Container Runtime Interface(CRI)

CRI는 컨테이너 런타임과 쿠버네티스 API 서버 사이의 표준 인터페이스이다. CRI를 사용하면 쿠버네티스는 다양한 컨테이너 런타임(Docker, rkt 등)에서 컨테이너를 실행할 수 있다.

### 2.4.15 Pod

Pod는 하나 이상의 컨테이너를 묶어서 관리하는 쿠버네티스의 최소 실행 단위이다. Pod 내부의 컨테이너들은 동일한 노드에서 실행되며, 네트워크와 파일 시스템을 공유한다.

Pod는 IP 주소와 포트를 공유하기 때문에, 같은 Pod 내부의 컨테이너끼리는 localhost를 통해 통신할 수 있다. Pod는 컨테이너를 단순히 묶는 개념이 아니라, 컨테이너 간의 관계를 정의하는 역할을 한다.

### 2.2.16 ReplicaSet

ReplicaSet은 Pod의 개수를 관리하는 리소스이다. ReplicaSet은 Pod을 생성하고, 각각의 Pod이 올바르게 동작하도록 관리한다. ReplicaSet은 Pod의 개수를 지정한 수만큼 늘리거나 줄일 수 있다.

### 2.2.17 Deployment

Deployment는 ReplicaSet을 관리하는 리소스이다. Deployment는 새로운 버전의 애플리케이션을 배포하거나, 롤백하는 등의 작업을 수행할 수 있다. Deployment는 버전 관리를 지원하며, 이전 버전과 새로운 버전을 비교하여 자동으로 롤백하는 기능을 제공한다.

### 2.2.18 Service

Service는 쿠버네티스 클러스터 내부에서 Pod에 접근하기 위한 추상화된 개념이다. Service는 Pod의 IP 주소와 포트를 추상화하여 클러스터 내부에서 접근하기 쉽도록 제공한다. Service는 Pod이 생성되고 제거될 때마다 Pod의 IP 주소와 포트 정보를 업데이트한다.

### 2.2.19 Ingress

Ingress는 클러스터 외부에서 쿠버네티스 클러스터 내부로 접근하기 위한 리소스이다. Ingress는 외부에서 들어오는 HTTP(S) 요청을 적절한 Service로 라우팅한다.

### 2.2.20 ConfigMap

ConfigMap은 컨테이너 내부의 설정 값을 관리하는 리소스이다. ConfigMap은 컨테이너의 설정 값을 YAML 파일로 정의하고, 컨테이너가 실행될 때 해당 값을 읽어와서 사용한다.

### 2.2.21 Secret

Secret은 컨테이너 내부의 민감한 정보를 관리하는 리소스이다. Secret은 컨테이너 내부에서 사용하는 비밀번호, 키, 인증서 등의 값을 안전하게 저장하고 관리한다.

## 2.4 장점

- 리소스관리(서버별 리소스 관리가능)
- 스케줄링(pod를 모니터링하며 새로운 컨테이너 배치시 리소스를 고려하여 최적의 노드를 찾아줌)
- process관리
- 통합설정관리
- 손쉬운장애대응
- 자동확장
- Hybrid Cloud
- 자가치유
- DB Storage관리
- 배포 자동화
